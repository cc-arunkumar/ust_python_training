from typing import Optional
from datetime import date, datetime
from pydantic import BaseModel
import re
import csv

# MaintenanceLog model definition using Pydantic for schema validation and type enforcement
class MaintenanceLog(BaseModel):
    log_id: Optional[int] = None   # Auto-increment primary key (optional, generated by DB)
    asset_tag: str                 # Asset tag, must follow "UST-XXXX" format
    maintenance_type: str          # Type of maintenance (Repair, Service, Upgrade)
    vendor_name: str               # Vendor name, alphabets and spaces only
    description: str               # Description of maintenance, minimum 10 characters
    cost: float                    # Cost of maintenance, positive number with up to 2 decimals
    maintenance_date: date         # Date of maintenance, cannot be in the future
    technician_name: str           # Technician name, alphabets and spaces only
    status: str                    # Status of maintenance (Completed, Pending)


# Function: Validate maintenance log fields against business rules
def validate_maintenance(log: MaintenanceLog) -> bool:
    errors = []

    # Asset tag must start with "UST-" followed by alphanumeric or hyphen
    if not re.match(r"^UST-[A-Za-z0-9-]+$", log.asset_tag):
        errors.append(f"Invalid asset_tag: {log.asset_tag}")

    # Maintenance type must be one of the allowed values
    allowed_types = ["Repair", "Service", "Upgrade"]
    if log.maintenance_type not in allowed_types:
        errors.append(f"Invalid maintenance_type: {log.maintenance_type}")

    # Vendor name must contain only alphabets and spaces
    if not re.match(r"^[A-Za-z ]+$", log.vendor_name):
        errors.append("Vendor name must contain only alphabets and spaces")

    # Description must be at least 10 characters long
    if not log.description or len(log.description.strip()) < 10:
        errors.append("Description must be at least 10 characters long")

    # Cost must be greater than 0 and have up to two decimal places
    if log.cost <= 0:
        errors.append("Cost must be greater than 0")
    if not re.match(r"^\d+(\.\d{1,2})?$", str(log.cost)):
        errors.append("Cost must have up to two decimal places")

    # Maintenance date cannot be in the future
    if log.maintenance_date > date.today():
        errors.append("Maintenance date cannot be in the future")

    # Technician name must contain only alphabets and spaces
    if not re.match(r"^[A-Za-z ]+$", log.technician_name):
        errors.append("Technician name must contain only alphabets and spaces")

    # Status must be either Completed or Pending
    allowed_status = ["Completed", "Pending"]
    if log.status not in allowed_status:
        errors.append(f"Invalid status: {log.status}")

    # Return False if any errors exist, otherwise True
    if errors:
        return False
    return True


# -------------------------------
# Example CSV validation workflow (commented out for production use)
# -------------------------------
# headers = []
# valid = []
# with open("../database/sample_data/maintenance_log.csv", "r") as file:
#     reader = csv.DictReader(file)
#     headers = reader.fieldnames
#     count = 0
#     for row in reader:
#         # Clean up whitespace in CSV values
#         clean_row = {k.strip(): (v.strip() if v else None) for k, v in row.items()}
#         
#         # Convert maintenance_date string to date object
#         if clean_row.get("maintenance_date"):
#             try:
#                 clean_row["maintenance_date"] = datetime.strptime(
#                     clean_row["maintenance_date"], "%Y-%m-%d"
#                 ).date()
#             except ValueError:
#                 # Skip rows with bad date format
#                 continue
#         
#         try:
#             new_maintenance = MaintenanceLog(**clean_row)   # Validate schema
#             if not validate_maintenance(new_maintenance):   # Apply business rules
#                 count += 1
#             else:
#                 valid.append(row)
#         except Exception as e:
#             count += 1
#
# # Write valid rows to final CSV
# with open("../database/sample_data/final_maintenance_log.csv", "w", newline="") as file:
#     writer = csv.DictWriter(file, fieldnames=headers)
#     writer.writeheader()
#     writer.writerows(valid)
