from fastapi import FastAPI, HTTPException, UploadFile, File, Query
from typing import Optional
from datetime import date
from src.config.db_connection import get_connection
import re
import csv
import io
import pymysql
from pydantic import BaseModel, validator

# Define the AssetModel class using Pydantic for validation
class AssetModel(BaseModel):
    asset_id: Optional[int] = None  # Asset ID is optional and will be generated by the database
    asset_tag: str  # Unique tag for the asset
    asset_type: str  # Type of the asset (Laptop, Monitor, etc.)
    serial_number: str  # Unique serial number of the asset
    manufacturer: str  # Manufacturer of the asset
    model: str  # Model of the asset
    purchase_date: date  # Purchase date of the asset
    warranty_years: int  # Warranty period in years
    condition_status: str  # Condition of the asset (New, Good, etc.)
    assigned_to: Optional[str] = None  # Optional: Employee or department to which the asset is assigned
    location: str  # Location of the asset (Trivandrum, Bangalore, etc.)
    asset_status: str  # Status of the asset (Available, Assigned, etc.)
    last_updated: Optional[str] = None  # Optional field to track the last update time of the asset

    # Validate the asset_tag field to ensure it starts with "UST-"
    @validator('asset_tag')
    def validate_asset_tag(cls, v):
        if not v.startswith("UST-"):
            raise ValueError('Asset tag must start with "UST-"')
        return v

    # Validate the asset_type to ensure it is one of the allowed types
    @validator('asset_type')
    def validate_asset_type(cls, v):
        allowed_types = ["Laptop", "Monitor", "Keyboard", "Mouse"]
        if v not in allowed_types:
            raise ValueError(f'Asset type must be one of {allowed_types}')
        return v

    # Validate the serial_number to ensure it is alphanumeric (including dashes and underscores)
    @validator('serial_number')
    def validate_serial_number(cls, v):
        if not re.match(r'^[A-Za-z0-9\-_]+$', v):
            raise ValueError('Serial number must be alphanumeric (letters, numbers, dashes, underscores)')
        return v

    # Validate the manufacturer to ensure it is one of the allowed manufacturers
    @validator('manufacturer')
    def validate_manufacturer(cls, v):
        allowed_manufacturers = ["Dell", "HP", "Lenovo", "Samsung", "LG", "Samsng"]
        if v not in allowed_manufacturers:
            raise ValueError(f'Manufacturer must be one of {allowed_manufacturers}')
        return v

    # Validate the model to ensure it is not empty or blank
    @validator('model')
    def validate_model(cls, v):
        if not v or not v.strip():
            raise ValueError('Model cannot be blank')
        return v

    # Validate the purchase_date to ensure the purchase date is not in the future
    @validator('purchase_date')
    def validate_purchase_date(cls, v):
        if v > date.today():
            raise ValueError('Purchase date cannot be in the future')
        return v

    # Validate warranty_years to ensure the warranty is between 0 and 5 years
    @validator('warranty_years')
    def validate_warranty_years(cls, v):
        if v < 0 or v > 5:
            raise ValueError('Warranty years must be between 0 and 5')
        return v

    # Validate condition_status to ensure it is one of the allowed conditions
    @validator('condition_status')
    def validate_condition_status(cls, v):
        allowed_conditions = ["New", "Good", "Used", "Damaged"]
        if v not in allowed_conditions:
            raise ValueError(f'Condition status must be one of {allowed_conditions}')
        return v

    # Validate assigned_to field to ensure it is not blank if provided
    @validator('assigned_to')
    def validate_assigned_to(cls, v):
        if v is not None and not v.strip():
            raise ValueError('Assigned_to cannot be blank if provided')
        return v

    # Validate location to ensure it is one of the allowed locations
    @validator('location')
    def validate_location(cls, v):
        allowed_locations = ["Trivandrum", "Bangalore", "Chennai", "Hyderabad"]
        if v not in allowed_locations:
            raise ValueError(f'Location must be one of {allowed_locations}')
        return v

    # Validate asset_status to ensure it is one of the allowed statuses
    @validator('asset_status')
    def validate_asset_status(cls, v):
        allowed_status = ["Available", "Assigned", "Repair", "Retired"]
        if v not in allowed_status:
            raise ValueError(f'Asset status must be one of {allowed_status}')
        return v

    # Configuration to ensure any string field is stripped of leading/trailing whitespaces
    class Config:
        min_anystr_length = 1  # Minimum length for any string field (other than optional fields)
        anystr_strip_whitespace = True  # Automatically strip leading and trailing spaces from strings

