from pydantic import BaseModel, validator
from typing import Optional
from datetime import date
import re

# Define the EmployeeModel class for validating employee data
class EmployeeModel(BaseModel):
    emp_id: Optional[int] = None  # Optional employee ID, generated by the database if not provided
    emp_code: str  # Employee code, must start with 'USTEMP'
    full_name: str  # Full name of the employee
    email: str  # Email of the employee
    phone: str  # Phone number of the employee (should be a valid Indian mobile number)
    department: str  # Department the employee belongs to
    location: str  # Employee's location, must be a valid UST location in India
    join_date: date  # Joining date of the employee (cannot be in the future)
    status: str  # Status of the employee (Active/Inactive/Resigned)

    # Validator for emp_code: It must start with 'USTEMP'
    @validator('emp_code')
    def validate_emp_code(cls, v):
        if not v.startswith("USTEMP"):
            raise ValueError('emp_code must start with "USTEMP"')
        return v

    # Validator for full_name: It must contain only alphabets and spaces
    @validator('full_name')
    def validate_full_name(cls, v):
        if not re.match(r'^[A-Za-z ]+$', v):  # Matches only alphabetic characters and spaces
            raise ValueError('full_name must contain only alphabets and spaces')
        return v.strip()  # Strips leading and trailing spaces

    # Validator for email: It must end with '@ust.com'
    @validator('email')
    def validate_email(cls, v):
        if not v.endswith("@ust.com"):  # Checks if email ends with '@ust.com'
            raise ValueError('email must end with "@ust.com"')
        return v

    # Validator for phone: It must be a valid 10-digit Indian mobile number
    @validator('phone')
    def validate_phone(cls, v):
        if not re.match(r'^[6-9]\d{9}$', v):  # Matches Indian phone numbers starting with 6-9 followed by 9 digits
            raise ValueError('phone must be a valid 10-digit Indian mobile number')
        return v

    # Validator for department: It must be one of the allowed departments (HR, IT, etc.)
    @validator('department')
    def validate_department(cls, v):
        allowed_departments = ["HR", "IT", "Admin", "Finance", "Support"]  # List of valid departments
        if v not in allowed_departments:
            raise ValueError(f'department must be one of {allowed_departments}')
        return v

    # Validator for location: It must be one of the allowed UST locations in India
    @validator('location')
    def validate_location(cls, v):
        allowed_locations = ["Trivandrum", "Bangalore", "Chennai", "Hyderabad", "Pune", "Mumbai", "Delhi"]  # Valid locations
        if v not in allowed_locations:
            raise ValueError(f'location must be one of {allowed_locations}')
        return v

    # Validator for join_date: It must not be a future date
    @validator('join_date')
    def validate_join_date(cls, v):
        if v > date.today():  # Checks if the join_date is in the future
            raise ValueError('join_date cannot be in the future')
        return v

    # Validator for status: It must be one of Active, Inactive, or Resigned
    @validator('status')
    def validate_status(cls, v):
        allowed_status = ["Active", "Inactive", "Resigned"]  # Valid status options
        if v not in allowed_status:
            raise ValueError(f'status must be one of {allowed_status}')
        return v

    # Configuration settings for the model
    class Config:
        min_anystr_length = 1  # Ensures the minimum length for string fields is 1 (non-empty)
        anystr_strip_whitespace = True  # Strips leading and trailing spaces from all string fields
