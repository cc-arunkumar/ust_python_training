
from fastapi import FastAPI, HTTPException
from pydantic import Field, field_validator, EmailStr, BaseModel
from typing import Optional
import pymysql
import datetime

# Initialize FastAPI application
app = FastAPI(title="Employee Management System")

# Database connection function
def get_connection():
    """
    Establishes and returns a connection to the MySQL database.
    Update credentials and database name as per your configuration.
    """
    return pymysql.connect(
        host="localhost",
        user="root",
        password="pass@word1",
        database="ust_db"
    )

# Pydantic model for Employee data validation
class Employee(BaseModel):
    employee_id: Optional[int]  # Auto-generated by DB, optional for input
    first_name: str = Field(..., max_length=50, description="cannot exceed more than 50 characters")
    last_name: str = Field(..., max_length=50, description="cannot exceed more than 50 characters")
    email: EmailStr = Field(..., max_length=100, description="must be a valid email address format")
    position: Optional[str] = Field(None, max_length=50)
    salary: Optional[float] = Field(None, ge=1, description='salary must be greater than 0 and negative values are not accepted')
    hire_date: str  # Expected format: YYYY-MM-DD

    # Validator for first_name and last_name
    @field_validator("first_name", "last_name")
    def validate_names(cls, v):
        """
        Ensures names are not empty and contain only alphabets, spaces, or hyphens.
        """
        if not v.strip():
            raise ValueError("Name must not be empty")
        if not all(c.isalpha() or c in [' ', '-'] for c in v):
            raise ValueError("Name must contain only alphabets, spaces, or hyphens")
        return v

    # Validator for position field
    @field_validator("position")
    def validate_position(cls, v):
        """
        Ensures position does not contain special characters like @, #, $, %.
        """
        if v and any(c in "@#$%" for c in v):
            raise ValueError("Position must not contain special characters like @, #, $, %")
        return v

    # Validator for hire_date field
    @field_validator("hire_date")
    def validate_hire_date(cls, v):
        """
        Ensures hire_date follows YYYY-MM-DD format and is not a future date.
        """
        try:
            date_obj = datetime.datetime.strptime(v, "%Y-%m-%d").date()
        except ValueError:
            raise ValueError("hire_date must follow YYYY-MM-DD format")
        if date_obj > datetime.date.today():
            raise ValueError("hire_date cannot be a future date")
        return v


# API endpoint to create a new employee
@app.post("/employees/")
def create_employee(employee: Employee):
    """
    Inserts a new employee record into the database.
    Returns the auto-generated employee_id.
    """
    conn = get_connection()
    cursor = conn.cursor()
    try:
        cursor.execute("""
            INSERT INTO ust_db.employees (first_name, last_name, email, position, salary, hire_date)
            VALUES (%s, %s, %s, %s, %s, %s)
        """, (employee.first_name, employee.last_name, employee.email,
              employee.position, employee.salary, employee.hire_date))
        conn.commit()
        return {"employee_id": cursor.lastrowid}
    except pymysql.err.IntegrityError:
        raise HTTPException(status_code=400, detail="Email must be unique")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        conn.close()


# API endpoint to fetch employee details by ID
@app.get("/employees/{employee_id}")
def get_employee_by_id(employee_id: int):
    """
    Retrieves employee details based on employee_id.
    Raises 404 if employee not found.
    """
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM ust_db.employees WHERE employee_id=%s", (employee_id,))
    result = cursor.fetchone()
    conn.close()
    if not result:
        raise HTTPException(status_code=404, detail="Employee not found")
    return result


# API endpoint to update employee details
@app.put("/employees/{employee_id}")
def update_employee(employee_id: int, employee: Employee):
    """
    Updates employee details for the given employee_id.
    Raises 404 if employee not found.
    """
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM ust_db.employees WHERE employee_id=%s", (employee_id,))
    if not cursor.fetchone():
        conn.close()
        raise HTTPException(status_code=404, detail="Employee not found")

    try:
        cursor.execute("""
            UPDATE ust_db.employees
            SET first_name=%s, last_name=%s, email=%s, position=%s, salary=%s, hire_date=%s
            WHERE employee_id=%s
        """, (employee.first_name, employee.last_name, employee.email,
              employee.position, employee.salary, employee.hire_date, employee_id))
        conn.commit()
        return {"message": "Employee updated successfully"}
    except pymysql.err.IntegrityError:
        raise HTTPException(status_code=400, detail="Email must be unique")
    finally:
        conn.close()


# API endpoint to delete an employee
@app.delete("/employees/{employee_id}")
def delete_employee(employee_id: int):
    """
    Deletes an employee record based on employee_id.
    Raises 404 if employee not found.
    """
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("DELETE FROM ust_db.employees WHERE employee_id=%s", (employee_id,))
    conn.commit()
    if cursor.rowcount == 0:
        conn.close()
        raise HTTPException(status_code=404, detail="Employee not found")
    conn.close()
